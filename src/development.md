明白了，我将为你撰写《BranchWrite1》的详细产品需求与开发文档，聚焦于 Mac 和 Windows 的纯本地版本，支持 Markdown 和纯文本，突出 Git 风格版本可视化与文本 diff 功能。将选用 TypeScript + Rust 技术栈，UI 框架为 React + Tauri，预留未来 AI 分析扩展能力。

我会整理好结构化的 PRD 与开发说明文档，稍后展示给你。


# BranchWrite1 产品需求文档（PRD）及开发说明

## 产品概述与用户目标

BranchWrite1 是一款面向跨平台（macOS 和 Windows）的本地离线写作软件，定位于服务半专业和专业的作家/小说家。其核心目标是在提供沉浸式写作环境的同时，引入类似 Git 的版本管理体验，帮助作家方便地追踪和管理创作过程中的各个版本演变。对于严肃写作者而言，传统文字处理软件往往缺乏细粒度的版本控制，而手动使用 Git 等工具又过于复杂。BranchWrite1 希望以直观友好的方式，将版本历史、差异对比等功能融入写作流程，让用户在专注写作的同时自动保存灵感演变，随时查看修改历程。

在用户目标方面，BranchWrite1 强调**本地优先**与**用户掌控**：所有内容和版本历史均保存在用户本地文件系统中，确保隐私和数据所有权。创作者可以离线使用软件，无需依赖网络或云服务，随时在旅途或无网环境下写作。面向专业写作者，BranchWrite1 提供纯文本和 Markdown 编辑支持，保证内容的高度可移植性和兼容性（Markdown 可用于导出和排版）。同时，软件提供简洁清晰的文件结构，用户能够方便地将整个项目文件夹打包、备份或迁移到其他设备继续创作。总体而言，BranchWrite1 的设计宗旨是为写作者打造一个**专注写作、自由掌控、版本清晰**的本地写作工具。

## MVP 功能列表与使用流程

**核心功能列表（MVP 阶段）**：

* **Markdown 与纯文本写作支持**：提供一个纯文本编辑器，用户可以直接进行无干扰的文字创作。编辑器兼容 Markdown 语法（例如标题、粗体、列表等标记），以便日后将文稿导出为排版良好的格式。但编辑器本身并不依赖复杂的所见即所得富文本控件，而是保持轻量纯粹的文本输入体验。用户在创作时既可当作普通文本输入，也可选择使用 Markdown 标记来结构化内容（如章节标题、斜体等），这些标记主要在导出或预览时发挥作用。

* **Git 风格的版本管理**：应用内置类似 Git 的版本控制机制，帮助用户自动记录文档演变并随时查看历史。

  * *自动/手动 Commit 快照*：软件会在后台自动生成版本快照（例如每隔一定时间或在用户完成一段落时），同时允许用户在需要时手动创建**提交(commit)**。每个提交可以附加简短说明，以记录该版本的修改要点。这样用户无需离开写作界面就能保存重要的里程碑版本。
  * *可视化历史时间线*：提供“历史版本”视图，以时间线或列表形式展示所有提交记录。每条记录显示提交时间、说明摘要等元数据，方便用户纵览版本演变。用户可以滚动浏览时间线，点击任一历史节点以预览当时的文稿内容。
  * *版本差异对比（diff）*：支持选中两个指定的版本进行内容差异比较。应用将以高亮方式呈现文本改动之处，例如新增的文字以绿色背景标出，删除或修改的部分以红色标出。用户可选择**并排对比**或**统一对比**视图查看差异（类似 GitHub 提交对比界面），清晰了解两个版本之间的改动细节。这样的差异高亮有助于用户回顾修改、撤销错误或从旧版本中找回被删减的内容。

* **本地文件存储与项目结构**：BranchWrite1 所有的数据都以简单透明的方式保存在本地文件系统中。每个写作项目对应一个独立文件夹，内部包含文稿内容和版本历史等数据文件。文件结构清晰，例如可能包含：`content.md`（当前文稿内容的 Markdown 文件）以及`history.json`（版本提交历史及差异的记录）。这种设计确保用户可以轻松地手动备份、导出或迁移项目——只需复制项目文件夹即可将作品带到其他设备上继续使用 BranchWrite1 打开编辑。**离线优先**是一大原则：软件的全部功能在离线状态下均可正常运作，不需登录或依赖云端。用户的数据也不会被锁定在某个专有格式中，项目中文件使用通用格式存储，最大程度保障用户对自己作品的控制权。

* **稳健的版本合并与扩展接口**：虽然 MVP 阶段专注单人离线使用，但底层已经考虑了未来扩展的需要。例如，版本管理模块采用**CRDT**（Conflict-Free Replicated Data Type）技术来跟踪文本变更，从而天然支持分支合并和多源编辑。得益于 CRDT（建议使用 Automerge v2 库）的数据结构，即便多个设备或用户对同一文稿做出更改，系统也能自动合并而不冲突，并保留完整的更改历史。虽然在 MVP 中不会正式推出多人协作或分支管理界面，但架构上已预留接口，为将来实现剧情分支写作、多人实时协作等功能做好准备。

上述功能协同，为作家提供了一套完善但不臃肿的写作与版本管理工具集。MVP 阶段摒弃了非必要的高级特性，确保核心体验（写作 + 版本控制）稳定可靠。

**典型使用流程**：

1. **创建项目**：用户启动 BranchWrite1，首先可以创建一个新的写作项目（或打开现有项目）。创建项目时为作品命名，软件会在本地生成相应的项目文件夹和初始文件结构（空的`content.md`及基础的`history.json`等）。

2. **专注写作**：进入项目后，用户在编辑器中开始写作。编辑器提供纯文本输入区域，支持基本的Markdown语法高亮。用户可以专心撰写内容，无需考虑版本管理的繁琐步骤。软件会实时自动保存修改（例如按键实时更新内存中的文档状态），并在后台按设定策略自动产出提交快照（比如每隔10分钟或每写满一定字数生成一次自动提交）。用户也可以在完成一个章节或重要修改后，手动点击“保存版本”按钮，新建一个提交并填写版本说明。

3. **查看历史版本**：写作一段时间后，用户随时可以打开“历史”面板。这里按时间顺序列出所有版本提交记录，包括自动和手动的提交。每条记录显示提交时间、提交类型（自动或用户提交）、以及用户填写的描述。用户点击某个历史记录，编辑器将切换到该版本的预览模式——显示当时文稿的只读内容，让用户回顾早先写的段落。用户可以通过明显的UI提示（比如颜色边框）知道自己当前在浏览历史版本，而非最新内容，避免混淆。

4. **比较差异**：在历史面板中，用户可以勾选两个不同的版本，然后点击“比较差异”功能。此时应用会打开一个差异对比视图。例如，屏幕上下或左右分割显示两个版本的文本，对应行对齐，并用高亮颜色标注增加、删除、修改的部分。用户能够清楚地看到修改之处，例如某段话在新版本中被删去了（旧版文本高亮为红色划除），某些句子被改写了（改动部分高亮标出），新增的内容以特殊颜色标注等。借助 React Diff Viewer 等组件，可以提供直观美观的差异高亮视图。通过对比，用户可确定修改是否合理，或定位到什么时候删掉了一段灵感。如果需要，用户还能选择将旧版本的内容复制回来（手动复制粘贴），或者**将整个文档回滚**到某个旧版本（MVP 可提供“另存为”旧版本的功能，避免直接覆盖当前版本）。

5. **继续创作与版本管理**：用户关闭差异视图后，可继续在最新版本上创作。整个过程中版本管理是无缝融入的：软件自动记录每次改动，又在用户需要时提供历史查询。不需要了解Git命令，写作者就能享受到版本控制带来的安全感和便利。每当用户需要导出作品（例如完成初稿后），可使用导出功能将当前版本内容导出为 Markdown 文件（或渲染为PDF/Word等格式，MVP阶段以 Markdown/纯文本导出为主）。由于文稿本身一直就是以 Markdown 格式书写，导出基本只是复制内容或经过简单转换，保证所见即所得。

6. **备份与迁移**：项目完结或中途，用户可以在资源管理器中找到对应的项目文件夹，将其压缩备份或同步到云盘，实现100%数据掌控。换一台电脑时，只需在新设备上安装 BranchWrite1，然后拷贝项目文件夹过去，即可无缝继续写作。

通过以上流程，BranchWrite1 将写作、保存、查阅历史、版本比较串联成一个闭环，让专业写作者安心创作、自由回溯每一次灵感演变。

## 技术架构与模块划分

**总体架构设计**：BranchWrite1 采用前后端分离的桌面应用架构。基于 **Tauri** 框架，前端使用 Web 技术构建界面，后端利用 Rust 提供系统能力支持。这种架构使应用既拥有跨平台图形界面开发的高效（前端技术栈）又具备桌面原生应用的性能和安全优势（Rust 后端）。总体上分为以下主要模块：

* **前端界面层（React + TypeScript）**：负责应用的用户界面和交互逻辑。使用 React 框架和 TypeScript 开发，结合 Tailwind CSS 或 Shadcn/UI 组件库进行样式布局，实现跨平台统一的现代化界面风格。前端主要包含以下子组件：

  * *编辑器组件*：主编辑窗口，负责文本内容的输入和展示。基于`<textarea>`、`contenteditable`或第三方编辑器控件实现（如未来可考虑集成 Monaco 或 CodeMirror）。MVP 阶段注重纯文本编辑，可选实现行号显示、Markdown 语法高亮等辅助功能。
  * *工具栏及菜单*：提供新建项目、提交版本、查看历史、导出等操作按钮和菜单项，与对应功能模块对接。
  * *历史时间线组件*：历史记录查看面板，列表或时间轴呈现提交记录。支持点击某记录触发预览或差异对比。
  * *差异对比组件*：用于显示两个版本之间的文本diff结果。可复用开源的 React Diff Viewer 组件，支持并排和统一视图切换，增删改高亮显示。该组件负责将版本差异数据渲染为直观的UI。
  * *对话框和通知*：如提交说明输入框（在手动commit时弹出让用户填写描述）、导出成功提示、错误提示等。

* **应用逻辑层（版本管理与文档模型）**：这一层作为前端与后端的桥梁，主要以 TypeScript 编写部分逻辑，并通过 Tauri 与 Rust 后端交互。核心逻辑包括：

  * *文档数据模型（基于 CRDT）*：文档采用 Automerge 提供的 CRDT 数据结构来表示。Automerge 允许文档状态在本地更改的同时保留修改日志，可在需要时生成任意历史版本的快照。在应用启动时，会从本地文件加载文档的初始状态（或空文档）。用户编辑时，通过 Automerge 的 API 将每次文本更改应用到文档状态中（例如插入字符、删除字符作为一系列操作）。由于 Automerge 的不可变状态设计，每次操作产生一个新状态，我们可以在内存中维护当前最新状态引用。
  * *版本管理模块*：管理 commit 的创建、历史列表、以及版本间的diff计算。这个模块提供方法让前端界面调用，如`createCommit(message)`将当前 Automerge 文档状态保存为新版本（记录到历史文件）；`getHistory()`返回所有版本的元信息列表；`getVersion(id)`加载某一版本的完整内容用于预览；`compareVersions(id1, id2)`生成两版本文本差异数据用于UI显示。
  * *Diff 差异计算引擎*：当用户请求比较两个版本时，调用文本差异计算引擎。可以基于现有算法（如 Myers diff 或 Google 的 diff-match-patch）来比对两份文本，生成增删改动的列表。由于我们可能使用现成组件（如 react-diff-viewer），内部或将利用其自带的diff算法。若采用 Monaco Editor 的 diff 功能，其内部同样有高效的diff实现。Diff 引擎输出的结构将传递给前端组件渲染。
  * *状态管理*：在前端可以使用 React Context 或 Zustand/Redux 等管理应用状态，例如当前文档内容（与 Automerge 文档同步更新）、当前所选历史版本、UI模式（编辑/预览/对比）等。确保不同组件（编辑器、历史列表、diff视图）之间状态一致协调。例如，当用户在历史列表点击某版本预览时，状态管理会将编辑器切换为相应内容的只读状态。

* **后端服务层（Tauri/Rust）**：Tauri 的 Rust 后端负责与操作系统交互及性能敏感的任务。模块划分包括：

  * *文件存储模块*：负责项目文件的读写。提供文件创建、保存、打开接口。例如`saveFile(path, data)`用于将给定数据写入指定路径（JSON 或 Markdown 文件），`readFile(path)`读取文件内容返回给前端。版本提交时，前端调用此模块将新的历史记录写入`history.json`，以及保存最新文本到`content.md`（或更新 Automerge 文档快照）。采用 Rust 操作文件系统，可确保速度和安全性，并利用操作系统对文件的锁和权限管理等特性。
  * *本地数据库或持久化支持*（可选）：MVP 中历史记录以JSON文件形式保存，不涉及复杂数据库。但如果未来需要，也可在Rust端引入轻量级数据库（如 SQLite）以管理更复杂的数据（例如AI分析结果缓存等）。MVP暂不需要此。
  * *Native 功能调用*：如调用系统对话框（选择文件导出路径等）、剪贴板、窗口管理等。这些通过 Tauri 提供的API或自定义 Rust 命令实现，并暴露给前端调用。

**模块交互**：当用户进行操作时，前端 UI 触发对应逻辑模块的方法。例如用户点击“提交”按钮，前端调用版本管理模块的`createCommit`，该方法使用 Automerge 获取当前文档状态的更改，并封装出一条新的提交记录，然后通过文件存储模块将更新写入本地。又如用户要求比较版本，前端调用`compareVersions(id1, id2)`，后端先从历史文件中读取两个版本对应的内容，然后由Diff引擎计算差异，结果返回前端组件显示。整个架构确保**前端专注界面与交互**、**后端专注数据存储与系统交互**，通过明确的接口分工实现解耦。

值得一提的是，由于使用了 CRDT/Automerge 作为核心数据结构，我们在架构上天然具备一些优势：所有更改都有完整历史记录，这与我们的版本控制需求不谋而合——每个提交可以看作 CRDT 文档历史中的一个状态点。后端保存的`history.json`可能并非简单地逐版本存储整篇文本，而是保存 Automerge 的更改记录（Patch）。在需要重建某版本内容时，可以从最初状态开始应用一系列 Patch 得到目标版本。这种方式类似于 Git 的增量存储思想，确保每次版本保存高效且不会产生大量冗余数据。项目文件夹保持人类可读和可理解，也便于未来扩展或调试时手工检查内容。

## 核心组件 API 设计

为了指导后续开发，实现上述功能，需要定义各核心模块的接口（API）。以下是 MVP 中关键组件及其主要接口概览：

* **文档模型（Document Model）**：封装 Automerge 文档对象，提供操作文档内容的接口。

  * `Document.applyChange(changeOps)`: 将一组文本变更操作应用到当前文档状态。例如插入字符串、删除字符等操作序列（由编辑器输入产生）通过此方法提交，更新 Automerge 内部状态。
  * `Document.getText()`：获取当前文档的纯文本内容表示。供编辑器显示或保存导出使用。
  * `Document.getState()`：获取当前 Automerge 文档的序列化状态（例如 Automerge 对象序列化后的 JSON 或二进制）。用于生成 commit 快照或持久化保存。
  * `Document.loadState(stateData)`: 从序列化状态载入文档，重建 Automerge 对象。这在打开项目或切换版本预览时使用。

* **版本管理器（Version Manager）**：管理版本快照的创建、存储和检索。

  * `VersionManager.createCommit(message?: string)`: 创建一个新的版本提交。它会调用 Document.getState() 获取当前文档状态，并生成一个 commit 对象（包含唯一ID、时间戳、提交消息、以及状态数据或状态引用）。新提交信息会追加保存到历史记录存储中。本地实现上，可以将状态变化以 CRDT Patch 形式记录，或保存完整文本快照。提交成功后返回 commit 的ID或元数据。
  * `VersionManager.getHistoryList()`：返回所有历史版本的元信息列表（按时间排序）。每项包括ID、时间、提交消息等，用于在UI中显示时间线。
  * `VersionManager.getCommit(commitId)`: 获取指定ID的提交详情，包括对应文档内容状态。内部会从本地存储读取commit记录，如果只保存了Patch则需要从初始状态重放所有patch至该版本，或者直接读取存储的文本快照。
  * `VersionManager.compare(commmitIdA, commitIdB)`: 对比两版本内容差异。内部流程：获取两个版本的文本内容（通过 Document.loadState 重建或已有文本），然后调用 Diff 引擎计算差异。返回的差异数据结构包括每个不同片段的位置、类型（新增/删除/修改）等，用于界面高亮显示。
  * `VersionManager.checkout(commitId)`: （如果支持分支或回滚）将当前编辑状态切换到指定版本。MVP 中可能只用于只读预览用途，而不真的改变当前编辑状态。但未来若实现分支编辑，可通过此接口从某历史版本创建新分支。

* **差异处理器（Diff Engine）**：封装文本比对算法，提供人类可读的差异结果。

  * `DiffEngine.diff(textOld: string, textNew: string)`: 比较两段文本，产生差异结果集。结果可采用例如统一diff格式或数组对象列表，包括行号、变更类型和内容等信息。这个模块可以内部使用第三方库实现，但通过统一接口封装，便于将来替换实现或调整参数。输出的数据将传递给 React 前端的差异对比组件进行渲染。
  * *（可选）* `DiffEngine.format(diffResult)`: 将差异结果整理为特定格式供显示，例如按行构造带标记的HTML片段等。如果使用react-diff-viewer，这步由组件自身完成，故MVP或可省略。

* **存储管理器（Storage）**：负责项目数据的读写，与文件系统交互。

  * `Storage.saveContent(filePath: string, text: string)`: 将文本内容保存到指定路径。主要用于更新当前文稿内容文件（如`content.md`）。
  * `Storage.saveHistory(filePath: string, historyData: object)`: 将版本历史数据（如最新提交列表或增量补丁）保存到指定路径（如`history.json`）。每次有新提交时调用，确保历史文件更新。
  * `Storage.loadContent(filePath: string) -> string`: 读取文本内容文件，返回全文字符串。在打开项目或预览历史版本时使用。
  * `Storage.loadHistory(filePath: string) -> object`: 读取历史记录文件，返回解析后的历史数据结构（提交列表及其差异信息等）。
  * `Storage.initProject(folderPath: string)`: 在指定目录创建新项目结构，生成初始的空文稿文件和历史记录文件（初始化 Automerge 文档状态并保存）。
  * 这些接口通过 Tauri 的命令从前端调用，由 Rust 实现具体文件I/O操作。考虑到 JSON 文件会随着提交增多而变大，未来可能引入压缩或只追加写入的机制，但 MVP 简单起见每次保存整个历史文件即可（因单人写作提交频率有限，JSON 文档仍较小）。

* **前端辅助接口**：一些界面交互相关的辅助API，例如：

  * `UI.showDiff(diffData)`: 调用差异组件将给定diff数据显示出来。
  * `UI.showPreview(commitContent)`: 在编辑器区域显示某版本只读内容。
  * `UI.promptCommitMessage()`: 弹出对话框让用户输入提交说明，返回字符串给VersionManager.createCommit使用。
  * 此类接口更多是前端内部方法，这里主要为了完整性提及。

通过上述组件与接口设计，各部分职责清晰：文档模型专注内容变更表示，版本管理负责版本的生成和获取，存储管控持久化，diff引擎计算差异。这些模块松耦合通过明确API交互，方便后续分别优化。例如，可独立替换Diff算法实现而不影响其他部分，或将来接入网络同步模块时，只需在VersionManager层扩展而不需重构整个系统。

## 技术选型理由

BranchWrite1 在技术栈选择上经过权衡，旨在平衡开发效率、性能和可维护性，具体选型及原因如下：

* **React + TypeScript + Tailwind CSS 前端框架**：采用 React 打造桌面应用的前端界面，得益于其组件化和广泛的社区支持，可以快速构建丰富的UI界面。TypeScript 则为代码提供静态类型检查，提高大型项目开发的可靠性和可维护性。Tailwind CSS 则用于快速样式开发，通过原子类可以方便地实现响应式布局和统一的设计风格。若引入 Shadcn/UI 组件库，它基于 Tailwind 和 Radix UI 封装了一系列可复用的无障碍组件（如按钮、对话框、菜单等），开发者可以直接采用并根据需要定制，从而在保持设计一致性的同时减少造轮子时间。这套前端栈为跨平台桌面应用提供了高效开发、精致UI和良好用户体验的保障。

* **Tauri (Rust) 桌面应用框架**：与传统的 Electron 不同，Tauri 能够生成体积小、资源占用低的原生应用。这对于写作软件这样的工具尤为重要——我们希望应用后台轻量、启动快，占用尽可能少的内存，让用户将系统资源集中用于实际写作内容而非应用自身开销。根据实测，Tauri 打包的应用通常只有几MB大小，相比 Electron 动辄数百MB的体积要小很多。同时，Tauri 应用运行时对内存和CPU的需求也更低，并且更加节能。安全性方面，Tauri 默认限制了前端对系统的直接访问，只暴露受控的API调用，提高了应用安全性——相对而言，Electron 应用由于直接运行Node.js，往往赋予前端更多系统权限，存在潜在安全隐患。总体而言，Tauri 基于 Rust 提供了更高性能和安全性的后端，实现了**更小的打包体积、更低的资源占用、更高的安全性**。对于跨平台支持，Tauri 同时兼容 Windows、macOS（以及 Linux），且可以利用操作系统自带的WebView渲染前端界面，无需捆绑笨重的浏览器内核，这也是其体积小的重要原因。基于上述优势，BranchWrite1 选择 Tauri 作为桌面封装方案，以期为用户提供一个轻巧敏捷的本地应用。

* **CRDT (Automerge) 版本控制数据结构**：在版本管理的核心数据层，选用 CRDT（尤其是 Automerge 库）来跟踪文档的所有修改。相比传统的仅保存全文快照或者使用行文本diff方案，CRDT 有独特优势：

  * *全历史记录*：Automerge 会记录文档的每一次更改，从而天然保留完整修改历史。这非常契合版本控制需求，使我们不用另行构建冗余的历史存储机制。用户可以在无需联网的情况下查看离线历史版本，正是因为 Automerge 将更改都持久化在本地。
  * *自动合并和分支*：CRDT 本身支持多源并发编辑的合并，Automerge 尤其将 Git 风格的分支、合并概念引入数据层。虽然 MVP 仅单人使用，但未来如果引入多人协作或剧情分支创作，CRDT 可以毫不冲突地合并不同修改，让每个人的更改都得以保留。这避免了传统版本控制在人为合并上的复杂操作。
  * *离线优先*：Automerge 贯彻 local-first 理念，即应用可在无服务器环境下运作，各设备离线编辑后再同步时 Automerge 差异合并。这与 BranchWrite1 强调的离线使用场景不谋而合。此外，Automerge 已有成熟的 JavaScript 和 Rust 实现，方便我们在 Tauri 架构中集成使用。
  * *实现简便*：利用 Automerge，我们可以专注于高层逻辑，而无需手写底层的版本差异算法或冲突处理算法。Automerge 提供了易用的API，开发者调用其函数即可完成状态更新、历史查询等操作。这显著降低了开发复杂度，同时由于其开源社区活跃，我们也能获得持续的性能改进和功能更新支持。

* **文本差异展示库**：为实现版本对比的可视化，我们考虑使用开源的 React 组件而非从零实现。一项合适的选择是 **React Diff Viewer**，它能够将两份文本的差异高亮渲染，以直观的方式展示给用户。其优点包括：

  * 内建\*\*统一(diff unified)**和**并排(diff split)\*\*视图模式，开发者和用户可以自由选择单栏或双栏对比。
  * 自动高亮新增、删除的部分，并支持对字级别、行级别的差异作区分显示，类似 GitHub 或 VS Code 的效果。
  * 高度可定制的样式，能够根据我们应用的主题调整配色和字体，以确保对比结果融入整体UI风格。
  * 开箱即用，集成简便：只需提供旧文本字符串、新文本字符串给组件，即可生成差异视图，避免我们自行处理复杂的diff算法和逐字符渲染逻辑。

  另一个方案是使用 **Monaco Editor** 提供的差异编辑器（DiffEditor）。Monaco 是 VS Code 所使用的文本编辑引擎 ，具备非常完善的代码编辑和对比功能。如果我们需要更强大的编辑体验（如代码高亮、大文本性能优化），可以考虑将 Monaco 用作主编辑器，并利用其内置的差异视图实现版本对比。然而，Monaco 体积相对较大，且主要优势在代码编辑场景。在 BranchWrite1 MVP 中，侧重点是写作文本，代码编辑特性并非刚需。因此我们倾向于采用轻量的 React Diff Viewer 来完成 diff 展示功能。如未来需求升级，再视情况引入 Monaco。

* **本地存储格式 (JSON + CRDT Patch)**：将版本历史记录保存为 JSON 文件是出于透明和可移植性的考虑。一方面，JSON 易于人阅读和解析，如果用户或开发者需要检查历史文件内容，可以直接打开查看，了解每个提交快照的信息。另一方面，JSON 作为通用格式，可以方便地被其它工具或脚本利用，降低数据被锁定的风险。结合 CRDT Patch（补丁）的方式存储，则能显著减少冗余数据量：每次提交只记录与前一版本的差异（补丁），而不是整个全文。这类似于 Git 保存增量的原理，保证即使版本很多，历史文件体积增长也较为缓和。同时，采用补丁存储也为将来实现**细粒度的版本合并**打下基础——因为每个补丁相当于一个操作集合，完全可以在不同分支间重用或移植。考虑到 Automerge 提供了相应的Change API，我们可以直接获取 Automerge 文档的更改集并序列化为JSON存入历史文件。当需要恢复某版本时，通过初始状态依次应用补丁列表即可得到目标状态。在实现上，这套机制只需使用简单的文件读写，无需引入复杂数据库，符合 MVP 对简洁性的追求。

综上，BranchWrite1 所选技术涵盖了当今前端和本地-first开发的先进工具。这些选型共同服务于我们的产品目标：提供卓越的用户体验（React界面）、安全高效的本地运行（Tauri+Rust）、可靠灵活的版本管理（CRDT）以及可持续扩展的架构。通过合理运用这些技术，我们有信心在有限的开发周期内交付满足用户需求的 MVP 产品。

## 后期扩展建议

在构建 MVP 的基础上，BranchWrite1 预留了未来功能扩展的空间。随着用户需求的深入，我们可以考虑以下方向进行产品演进：

* **AI 剧情诊断与写作辅助**：集成大语言模型（LLM）或其他AI技术，为作家提供智能辅助。具体构想包括：剧情连贯性诊断（AI阅读当前稿件并指出情节矛盾或松散之处），角色行为一致性检查，文本风格分析等。AI 模块可以以插件形式接入，通过接口获取当前文稿内容，输出建议或报告。例如用户点击“AI 剧情诊断”按钮后，后台调用本地或云端AI服务分析全文，在侧边栏呈现分析结果（如剧情曲线、冲突点、悬念点等）。另一个实用方向是**AI 写作助手**，例如根据上下文续写一段文本、提供措辞优化建议，或者根据大纲生成情节草稿等。这些功能在架构上可通过调用开放的AI API（如OpenAI接口）实现，我们需要做好接口设计，保证AI读取或修改文档时与CRDT的数据一致性。鉴于MVP已使用TypeScript和Rust，有成熟的AI客户端库，可在未来集成时较容易地进行对接。

* **剧情节点图谱**：为支撑小说剧情的规划与多线发展，考虑加入“剧情节点图”功能。该功能提供一个可视化画布，用户可以将故事的章节、场景或人物关系以节点-连线的形式组织展示。例如每个节点代表一个情节事件，节点间连线表示前因后果或并行发展的剧情线。作家能够在图上直观地梳理故事结构，规划不同分支走向。未来若支持互动小说或多线叙事，这种图谱尤为重要。实现上，剧情图谱模块可以独立于文本编辑存在，但与文稿内容关联——比如节点附加备注或链接到实际章节文本的位置。技术上可使用前端图形库（如D3.js或Mermaid）绘制交互式流程图。MVP 阶段不实现具体功能，但可在数据层为节点图预留接口（如Document模型中支持关联节点ID的标记，或项目文件结构中增加`outline.json`草稿文件）。等到开发剧情图时，只需利用这些预留的数据挂钩，将文本与图谱关联起来。剧情节点图将帮助作家更好地构思复杂故事，提高创作效率。

* **多人协作与云同步**：当前版本聚焦单人离线使用，但随着CRDT天生支持多副本同步，我们可以展望添加多人协同写作模式。未来扩展时，可以引入一个**实时协作**模块：通过局域网直连或云服务器中转，实现多位作者对同一文档的同步编辑。由于CRDT能自动合并并保存并发更改，协作过程中的冲突将自动解决，每个人的客户端都保持一致状态。我们需要为此设计协作流程，例如用户发起协作邀请、对方加入项目，共同编辑并看到彼此光标和修改高亮等。安全方面，可考虑基于密码学确保只授权用户参与协作。除了实时协同，也可拓展**云端备份/同步**功能，让单人用户在多设备上通过网络同步自己的写作项目（例如利用WebDAV或专有云服务）。这些都建立在当前本地存储格式之上，主要增加同步协议和UI界面部分。

* **更丰富的编辑器功能**：在写作软件领域，还有许多可添加的辅助功能。未来版本可以考虑引入：**Markdown 实时预览**（分屏显示渲染后的格式，以满足部分用户所见即所得的需求）、**字数统计及写作进度**（统计当前章节字数、全书字数，设置每日写作目标提醒等）、**版本标签和里程碑**（允许用户将某些提交标记为里程碑版本，如“初稿完成”、“修改稿1”等，方便管理大量的历史版本），**导出格式扩展**（如导出 EPUB 电子书、PDF 排版、HTML 网页等，以适应不同出版需求）等等。由于我们采用模块化架构，这些新功能多为在现有模块上附加功能或与之集成，例如字数统计可由前端实时计算显示，导出则利用现有Markdown内容通过第三方库转换。

* **移动端支持**：虽然 BranchWrite1 当前专注桌面端，但长远来看，作家可能希望随时随地记录灵感，包括在平板或手机上编辑内容。Tauri 正在开发移动端支持，未来我们可以评估将 BranchWrite1 打包为移动应用的可行性。如果移动端实现困难，也可考虑提供**纯文本同步编辑**的简化客户端，或者与现有笔记应用联动。无论如何，核心还是利用已有的CRDT同步机制，保证不同设备间编辑内容无缝合并。

总之，BranchWrite1 的后续版本将围绕**提升写作体验和创作效率**不断演进。从 AI 助手到剧情规划，再到协同创作，各项扩展都会基于 MVP 奠定的本地优先、版本完备的基础来实现。在满足专业作家严苛需求的道路上，BranchWrite1 将不断丰富功能，同时保持软件的简洁稳定，为创作者提供强有力的技术支持。各新模块的加入也会遵循组件化原则，与现有架构松耦合，确保应用可以平滑过渡和升级，不断成长为作家创作流程中不可或缺的工具。
